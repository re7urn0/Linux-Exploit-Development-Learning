## Stack based buffer overflow

​	缓冲区溢出是源数据复制到目标缓冲区导致的数据溢出，其中源字符串长度大于目标缓冲区长度，且未做数据大小检查。该漏洞的核心原理是：**用户输入的数据溢出目标缓冲区并覆盖堆栈中的返回地址，攻击者在返回地址上写入要执行的Shellcode的地址。**

​	漏洞代码: 

```c
//vuln.c
#include <stdio.h>
#include <string.h>
int main(int argc, char* argv[]) {
        /* [1] */ char buf[256];
        /* [2] */ strcpy(buf,argv[1]);
        /* [3] */ printf("Input:%s\n",buf);
        return 0;
}
```

​	编译代码(禁用ASLR；关闭栈保护；标记堆栈为可执行；ELF文件执行时获得root权限)：

```shell
#echo 0 > /proc/sys/kernel/randomize_va_space 
$gcc -g -fno-stack-protector -z execstack -o vuln vuln.c
$sudo chown root vuln
$sudo chgrp root vuln
$sudo chmod +s vuln
```

​	反汇编代码：

`(gdb) disassemble main
Dump of assembler code for function main:
   0x08048414 <+0>:	    push   %ebp
   0x08048415 <+1>:	    mov    %esp,%ebp
   0x08048417 <+3>:	    and    $0xfffffff0,%esp
   0x0804841a <+6>:	    sub    $0x110,%esp
   0x08048420 <+12>:	mov    0xc(%ebp),%eax
   0x08048423 <+15>:	add    $0x4,%eax
   0x08048426 <+18>:	mov    (%eax),%eax
   0x08048428 <+20>:	mov    %eax,0x4(%esp)
   0x0804842c <+24>:	lea    0x10(%esp),%eax
   0x08048430 <+28>:	mov    %eax,(%esp)
   0x08048433 <+31>:	call   0x8048330 <strcpy@plt>
   0x08048438 <+36>:	mov    $0x8048530,%eax
   0x0804843d <+41>:	lea    0x10(%esp),%edx
   0x08048441 <+45>:	mov    %edx,0x4(%esp)
   0x08048445 <+49>:	mov    %eax,(%esp)
   0x08048448 <+52>:	call   0x8048320 <printf@plt>
   0x0804844d <+57>:	mov    $0x0,%eax
   0x08048452 <+62>:	leave  
   0x08048453 <+63>:	ret    
End of assembler dump.`

缓冲区（buf）到目标函数（strcpy）返回地址的偏移量：**0x10c = 0x100 + 0x8 + 0x4**，

0x100是buf的大小，0x8是对齐空间，0x4是调用函数的EBP。

​	因此，编写利用代码：











